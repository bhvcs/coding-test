프로그래머스 해시

1. 포켄몬

import java.util.HashMap;
import java.util.Map;


class Solution{
    public static long solution(int[] pkms){
        HashMap<Integer, String> map = new HashMap<>();
        int num = pkms.length;
        int pick = num/2;
        for(int pkm: pkms){
            map.put(pkm, null);
        }
        int n = 0;
        for (Map.Entry<Integer, String> entry: map.entrySet()){
            if (n >= pick){
                break;
            }
            n++;
        }
        
        return n;
        
    }
}

다른 사람들의 풀이를 보았다.
이건 나도 생각하고 있던 건데 활용하지 않았다. map.size()로 해시의 크기를 확인하고, 이 크기가 num/2 보다 작다면 해당 값을 선택하는 방향으로 갔다면, 밑에 for문이 없어져도 될 것이다.

다른 풀이에서는 HashSet을 활용했다. HashSet은 키-값을 저장하는게 아닌 객체만을 저장한다. 물론 내부적으로 HashMap이 구현되어 있고 실제로도 저장하는 객체 뿐 아니라, dummy 객체도 저장한다고 한다.
HashSet은 키-값을 넣어주지 않아도 되서 이 문제를 풀이할 때, 더 유리할거라고 생각했지만, 객체만을 저장하는 HashSet의 특성 탓에 HashMap 보다도 더 느리다는 이야기를 들었다.

참고로, HashMap은 중복된 키는 허용하지 않되, 다른 value는 허용한다. 반면, HashSet은 객체만을 받기 때문에 중복을 허용하지 않는다.

2. 완주하지 못한 선수
import java.util.*;

class Solution{
    public static String solution(String[] parti, String[] compl){
        Arrays.sort(parti);
        Arrays.sort(compl);
        int pick = 0;
        for(int i=0; i<compl.length; i++){
            if (!(parti[i].equals(compl[i]))){
                return parti[i];
            }
        }
        return parti[parti.length-1];
    }
}
이게 처음 풀이에서의 내 코드이다. 배열 내의 string들을 정렬하고, 앞에서부터 순서대로 parti와 compl을 동일한지 검사해서, 동일하지 않은 순번의 그 사람이, 완주하지 못한 사람으로 골랐다.
일단 해시를 사용해서 문제를 풀어야 하는 상황에 맞지 않았다.

그래서 다른 사람의 풀이를 보았다. 
내가 이해하기로는 먼저 participant 들을 모두 HashMap<String, Integer>에 넣는다. 넣을 때, value 부분에 getOrDefault(key, 0) 로 기존에 들어간 인원 중 동명이인이 없었다면 0->1로,
있다면 해당 value 값에 1을 더해, 해당 동명이인이 몇 명인지까지 표기했다.
그러고, completion 배열을 돌면서 기존에 할당된 value 값에서 하나씩 빼기로 하였다. 그러면 최후에 0이 아닌(1이겠지) key-value 가 있을 것이고, 해당 값을 찾아서 반환하는 것이다.
나도 이러한 방법과 비슷한 생각을 했었다. 다만, value 값에 동명이인들을 표기하기 위해 각기 다른 번호를 배열에 집어넣는 식으로 할까 생각했었고, 별로 효율적이라는 생각이 안들었다.
해당 풀이를 보니, 꼭 동명이인이 구별될 필요가 있었을까? 결국 동명이인의 수만이 중요했던 것이다. 그래서 이렇게 동명이인의 명 수를 깔끔하게 Integer로 나타낼 수 있는 것이었다.


